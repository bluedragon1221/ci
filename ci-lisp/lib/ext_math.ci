((def (fn 'f (fn 'g (fn 'x (g (f x)))))) 'compose)
((def (fn 'f (fn 'g ((compose g) f)))) 'pipe)

((def (fn 'f
    ((fn 'x (f (fn 'v ((x x) v))))
     (fn 'x (f (fn 'v ((x x) v)))))
  ))
'Z)

("== Booleans")
((def (fn 'x (((if x) nil) t))) 'not)

("== Cons pairs")
((def (fn 'b (fn 'a (fn 'u ((u a) b))))) 'cons)
((def (fn 'p (p (fn 'car_x (fn 'y car_x))))) 'car)
((def (fn 'p (p (fn 'cdr_x (fn 'y y))))) 'cdr)
((def (fn 'p ((cons (car p)) (cdr p)))) 'swap)

((def (fn 'p {"{" str_concat {(car p) str_concat {" : " str_concat {(cdr p) str_concat "}"}}}})) 'fmt_pair)

("== Fractions")
((def (Z (fn 'divmod_inner (fn 'q (fn 'divisor (fn 'dividend
 ((((if {dividend < divisor})
    (fn '_ {q cons dividend}))
    (fn '_ (((divmod_inner (inc q)) divisor) {dividend sub divisor})))
  nil)
)))))) 'divmod_inner)
((def (divmod_inner 0)) 'divmod)

((def (fn 'b (fn 'a (car {a divmod b})))) 'div)
((def (fn 'b (fn 'a (cdr {a divmod b})))) 'mod)

((def (Z (fn 'gcd (fn 'a (fn 'b
  ((((if {b eq 0})
     (fn '_ a))
     (fn '_ ((gcd b) {a mod b})))
   nil)
))))) 'gcd)

((def (fn 'd (fn 'n {'frac cons {n cons d}}))) 'frac)
((def (eq 'frac)) 'is_frac)

((def (fn 'f (car (cdr f)))) 'num)
((def (fn 'f (cdr (cdr f)))) 'denom)

((def (fn 'a (fn 'b
  {{(num a) add (num b)} frac {(denom a) mul (denom b)}}
))) 'fadd)

((def (fn 'a (fn 'b
  {{(num a) mul (num b)} frac {(denom a) mul (denom b)}}
))) 'fmul)

((def (fn 'f ((fn 's
  {(s (num f)) frac (s (denom f))}
) (div ((gcd (num f)) (denom f)))))) 'fsimplify)

((def (fn 'f {(num f) str_concat {"/" str_concat (denom f)}})) 'fmt_frac)

("== Lists")
("use [1 2 3] to make a list")

((def (fn 'n (fn 'list
  ((((if ((eq n) 0))
     (fn '_ (car list)))
     (fn '_ ((nth (dec n)) (cdr list))))
   nil))))
'nth)

((def (Z (fn 'fmt_list_inner (fn 'acc (fn 'rest
  (((if {rest eq nil})
    ((log "acc") acc))
    ((fmt_list_inner {acc str_concat {" " str_concat (car rest)}}) (cdr rest)))
))))) 'fmt_list_inner)
((def (fn 'lst ((fmt_list_inner "") lst))) 'fmt_list)
