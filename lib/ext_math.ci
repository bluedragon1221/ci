("Pointfree stuff")
((def ((doc "Create the composition (f (g x)) from function arguments g and f") (fn 'g (fn 'f (fn 'x (f (g x))))))) 'compose)
((def (fn 'f (fn 'x (f x)))) 'pipe)
((def (fn 'f (fn 'x (fn 'y ((f y) x))))) 'flip)

("// SKI combinator calculus")
((def (fn 'f (fn 'g (fn 'a ((f a) (g a)))))) 'fork) ("aka S")
((def (fn 'x (fn '_ x))) 'const) ("aka K")
((def (fn 'x x)) 'id) ("aka I")

((def (fn 'f
    ((fn 'x (f (fn 'v ((x x) v))))
     (fn 'x (f (fn 'v ((x x) v)))))
  ))
'Z)

((def (fn 'x (fn 'f (f x)))) 'let)

("== Booleans")
((def (fn 'x (((if x) nil) t))) 'not)

((def (fn 'x (fn 'y
  (((if x) y) nil)
))) 'and)
((def (fn 'x (fn 'y
  (((if x) nil) y)
))) 'or)

((def builtin__int_add) 'add)
((def builtin__int_sub) 'sub)
((def builtin__int_mul) 'mul)

("== String Manipulation")
((def (fn 'sep (fn 'b (fn 'a
  {a str_concat {sep str_concat b}}
)))) 'join)

("== Cons pairs")
((def ((doc "Constructs a pair, given two elements") (fn 'b (fn 'a (fn 'cons_u ((cons_u a) b)))))) 'cons)
((def ((doc "Gets the first element of a given pair") (fn 'p (p (fn 'car_x (fn 'y car_x)))))) 'car)
((def ((doc "Gets the second/last element of a given pair") (fn 'p (p (fn 'cdr_x (fn 'y y)))))) 'cdr)
((def ((doc "Reverses a given pair. `{a : b}` => `{b : a}`") (fn 'p ((cons (car p)) (cdr p))))) 'swap)

((def ((doc "Formats a pair as a string to view its contents") (fn 'p
  {"{" (join ({(car p) (join " : ") (cdr p)})) "}"}
))) 'fmt_pair)

("== Fractions")
((def ((doc "Given an integer dividend and divisor, compute their quotient and remainder, returned as a tuple {quotient : remainder}") ((Z (fn 'divmod_inner (fn 'q (fn 'divisor (fn 'dividend
 ((((if {dividend lt divisor})
    (fn '_ {q cons dividend}))
    (fn '_ (((divmod_inner (inc q)) divisor) {dividend sub divisor})))
  nil)
))))) 0))) 'divmod)

((def ((flip ((compose divmod) compose)) car)) 'div)
((def ((flip ((compose divmod) compose)) cdr)) 'mod)

((def (Z (fn 'gcd (fn 'a (fn 'b
  ((((if {b eq 0})
     (fn '_ a))
     (fn '_ ((gcd b) {a mod b})))
   nil)
))))) 'gcd)

((def ((doc "Create a new fraction, given a numerator and denominator") (fn 'd (fn 'n {'frac cons {n cons d}})))) 'frac)
((def ((compose car) (eq 'frac))) 'is_frac)

((def ((compose cdr) car)) 'num)
((def ((compose cdr) cdr)) 'denom)

((def ((doc "Add two fractions") (fn 'b (fn 'a
  (fsimplify
    {{{(num a) mul (denom b)} add {(num b) mul (denom a)}} frac {(denom a) mul (denom b)}}
))))) 'fadd)

((def ((doc "Subtract two fractions") (fn 'b (fn 'a
  (fsimplify
    {{{(num a) mul (denom b)} sub {(num b) mul (denom a)}} frac {(denom a) mul (denom b)}}
))))) 'fsub)

((def ((doc "Multiply two fractions") (fn 'b (fn 'a
  {{(num a) mul (num b)} frac {(denom a) mul (denom b)}}
)))) 'fmul)

((def ((doc "Simplify a given fraction") (fn 'f
  ((let ((gcd (num f)) (denom f)))
    (fn 'gcd {{(num f) div gcd} frac {(denom f) div gcd}})
  )
))) 'fsimplify)

((def ((doc "Format a fraction as a string to view its contents")
  ((fork ((compose denom) (join "/"))) num)
)) 'fmt_frac)

("== Lists")
("use [1 2 3] to make a list")

((def ((doc "Get the nth item of a list. List indices start at 0") (Z (fn 'nth (fn 'n (fn 'list
  (
    (((if {n eq 0})
      (fn '_ (car list)))
      (fn '_ ((nth (dec n)) (cdr list))))
  nil)
)))))) 'nth)

((def ((doc "Get the length of a given list") ((Z (fn 'len_inner (fn 'n (fn 'lst
  (
    (((if (not lst))
      (fn '_ n))
      (fn '_ ((len_inner (inc n)) (cdr lst))))
  nil)
)))) 0))) 'len)

((def ((doc "Create a list of length `n` filled with item `c`") (Z (fn 'repeat (fn 'n (fn 'c
  (
    (((if {n eq 0})
      (fn '_ []))
      (fn '_ {c cons ((repeat (dec n)) c)}))
  nil)
)))))) 'repeat)

((def ((doc "Create a list that counts from `low` to `high`") (Z (fn 'range (fn 'low (fn 'high
  (
    (((if {high lt low})
      (fn '_ []))
      (fn '_ {low cons ((range (inc low)) high)}))
  nil)
)))))) 'range)

((def ((doc "Applies the foldr function.
Args:
- `f`: Define how to merge one item with the accumulator from the right. ex. `(fn 'x (fn 'acc ...))`
- `acc`: The default value to start with. ex. `[]`
- `lst`: The list of elements you're applying the fold to
") (Z (fn 'foldr (fn 'f (fn 'acc (fn 'lst
  ((((if (not lst))
    (fn '_ acc))
    (fn '_ ((f (car lst)) (((foldr f) acc) (cdr lst)))))
  nil)
))))))) 'foldr)

((def ((doc "Sum a list") ((foldr (fn 'x (fn 'acc {x + acc}))) 0))) 'sum)

("See https://jstolarek.github.io/posts/2012-07-30-expressing-foldl-in-terms-of-foldr.html")
((def ((doc "Applies the foldl function.
Args:
- `f`: Define how you want to merge one item with the accumulator from the left. ex. `(fn 'acc (fn 'x ...))`
- `acc`: The default value to start with. ex. `[]`
- `lst`: The list of elements you're applying the fold to
Note: If you're working with lists, consider using foldr.
This allows you to use `cons` in your accumulator function, which is much more efficient (O(1)) than trying to append an item (O(n)).
") (fn 'f (fn 'acc (fn 'lst
  ((((foldr
    (fn 'x (fn 'g (fn 'acc (g ((f acc) x))))) )
    id)
    lst)
  acc)
))))) 'foldl)

((def ((doc "Apply a function to every argument in a list
Args:
- `f`: The function you want to apply
- `lst`: The list you're acting on
") (fn 'f
  ((foldr (fn 'x (fn 'acc {(f x) cons acc}))) [])
))) 'map)

((def (fn 'c
  ((foldr (fn 'x (fn 'acc
    (((if (c x))
      {x cons acc})
      acc)
  ))) [])
)) 'filter)

((def ((doc "Format a list as a string to view its contents")
  ((compose ((foldl (flip (join " "))) "[")) (str_concat " ]"))
)) 'fmt_list)

("== alists (Hashmaps)")
((def (fn 'h {'alist cons h})) 'alist)
((def (fn 'h {(car h) eq 'alist})) 'is_alist)

((def (fn 'elem (fn 'h
  (cdr
    (car
      ((filter (fn 'x {(car x) eq elem})) (cdr h))))
))) 'get)
